/**
  ******************************************************************************
  * @file           : oled.c
  * @brief          : SSD1306 OLED Driver Implementation
  ******************************************************************************
  */

#include "oled.h"

/* ======================== Display Buffer ======================== */

static uint8_t OLED_Buffer[OLED_WIDTH * OLED_PAGES];

/* ======================== 6x8 ASCII Font ======================== */

static const uint8_t Font6x8[][6] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Space
    {0x00, 0x00, 0x5F, 0x00, 0x00, 0x00}, // !
    {0x00, 0x07, 0x00, 0x07, 0x00, 0x00}, // "
    {0x14, 0x7F, 0x14, 0x7F, 0x14, 0x00}, // #
    {0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x00}, // $
    {0x23, 0x13, 0x08, 0x64, 0x62, 0x00}, // %
    {0x36, 0x49, 0x55, 0x22, 0x50, 0x00}, // &
    {0x00, 0x05, 0x03, 0x00, 0x00, 0x00}, // '
    {0x00, 0x1C, 0x22, 0x41, 0x00, 0x00}, // (
    {0x00, 0x41, 0x22, 0x1C, 0x00, 0x00}, // )
    {0x08, 0x2A, 0x1C, 0x2A, 0x08, 0x00}, // *
    {0x08, 0x08, 0x3E, 0x08, 0x08, 0x00}, // +
    {0x00, 0x50, 0x30, 0x00, 0x00, 0x00}, // ,
    {0x08, 0x08, 0x08, 0x08, 0x08, 0x00}, // -
    {0x00, 0x60, 0x60, 0x00, 0x00, 0x00}, // .
    {0x20, 0x10, 0x08, 0x04, 0x02, 0x00}, // /
    {0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00}, // 0
    {0x00, 0x42, 0x7F, 0x40, 0x00, 0x00}, // 1
    {0x42, 0x61, 0x51, 0x49, 0x46, 0x00}, // 2
    {0x21, 0x41, 0x45, 0x4B, 0x31, 0x00}, // 3
    {0x18, 0x14, 0x12, 0x7F, 0x10, 0x00}, // 4
    {0x27, 0x45, 0x45, 0x45, 0x39, 0x00}, // 5
    {0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00}, // 6
    {0x01, 0x71, 0x09, 0x05, 0x03, 0x00}, // 7
    {0x36, 0x49, 0x49, 0x49, 0x36, 0x00}, // 8
    {0x06, 0x49, 0x49, 0x29, 0x1E, 0x00}, // 9
    {0x00, 0x36, 0x36, 0x00, 0x00, 0x00}, // :
    {0x00, 0x56, 0x36, 0x00, 0x00, 0x00}, // ;
    {0x00, 0x08, 0x14, 0x22, 0x41, 0x00}, // <
    {0x14, 0x14, 0x14, 0x14, 0x14, 0x00}, // =
    {0x41, 0x22, 0x14, 0x08, 0x00, 0x00}, // >
    {0x02, 0x01, 0x51, 0x09, 0x06, 0x00}, // ?
    {0x32, 0x49, 0x79, 0x41, 0x3E, 0x00}, // @
    {0x7E, 0x11, 0x11, 0x11, 0x7E, 0x00}, // A
    {0x7F, 0x49, 0x49, 0x49, 0x36, 0x00}, // B
    {0x3E, 0x41, 0x41, 0x41, 0x22, 0x00}, // C
    {0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00}, // D
    {0x7F, 0x49, 0x49, 0x49, 0x41, 0x00}, // E
    {0x7F, 0x09, 0x09, 0x01, 0x01, 0x00}, // F
    {0x3E, 0x41, 0x41, 0x51, 0x32, 0x00}, // G
    {0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00}, // H
    {0x00, 0x41, 0x7F, 0x41, 0x00, 0x00}, // I
    {0x20, 0x40, 0x41, 0x3F, 0x01, 0x00}, // J
    {0x7F, 0x08, 0x14, 0x22, 0x41, 0x00}, // K
    {0x7F, 0x40, 0x40, 0x40, 0x40, 0x00}, // L
    {0x7F, 0x02, 0x04, 0x02, 0x7F, 0x00}, // M
    {0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00}, // N
    {0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00}, // O
    {0x7F, 0x09, 0x09, 0x09, 0x06, 0x00}, // P
    {0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00}, // Q
    {0x7F, 0x09, 0x19, 0x29, 0x46, 0x00}, // R
    {0x46, 0x49, 0x49, 0x49, 0x31, 0x00}, // S
    {0x01, 0x01, 0x7F, 0x01, 0x01, 0x00}, // T
    {0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00}, // U
    {0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00}, // V
    {0x7F, 0x20, 0x18, 0x20, 0x7F, 0x00}, // W
    {0x63, 0x14, 0x08, 0x14, 0x63, 0x00}, // X
    {0x03, 0x04, 0x78, 0x04, 0x03, 0x00}, // Y
    {0x61, 0x51, 0x49, 0x45, 0x43, 0x00}, // Z
    {0x00, 0x00, 0x7F, 0x41, 0x41, 0x00}, // [
    {0x02, 0x04, 0x08, 0x10, 0x20, 0x00}, // backslash
    {0x41, 0x41, 0x7F, 0x00, 0x00, 0x00}, // ]
    {0x04, 0x02, 0x01, 0x02, 0x04, 0x00}, // ^
    {0x40, 0x40, 0x40, 0x40, 0x40, 0x00}, // _
    {0x00, 0x01, 0x02, 0x04, 0x00, 0x00}, // `
    {0x20, 0x54, 0x54, 0x54, 0x78, 0x00}, // a
    {0x7F, 0x48, 0x44, 0x44, 0x38, 0x00}, // b
    {0x38, 0x44, 0x44, 0x44, 0x20, 0x00}, // c
    {0x38, 0x44, 0x44, 0x48, 0x7F, 0x00}, // d
    {0x38, 0x54, 0x54, 0x54, 0x18, 0x00}, // e
    {0x08, 0x7E, 0x09, 0x01, 0x02, 0x00}, // f
    {0x08, 0x14, 0x54, 0x54, 0x3C, 0x00}, // g
    {0x7F, 0x08, 0x04, 0x04, 0x78, 0x00}, // h
    {0x00, 0x44, 0x7D, 0x40, 0x00, 0x00}, // i
    {0x20, 0x40, 0x44, 0x3D, 0x00, 0x00}, // j
    {0x00, 0x7F, 0x10, 0x28, 0x44, 0x00}, // k
    {0x00, 0x41, 0x7F, 0x40, 0x00, 0x00}, // l
    {0x7C, 0x04, 0x18, 0x04, 0x78, 0x00}, // m
    {0x7C, 0x08, 0x04, 0x04, 0x78, 0x00}, // n
    {0x38, 0x44, 0x44, 0x44, 0x38, 0x00}, // o
    {0x7C, 0x14, 0x14, 0x14, 0x08, 0x00}, // p
    {0x08, 0x14, 0x14, 0x18, 0x7C, 0x00}, // q
    {0x7C, 0x08, 0x04, 0x04, 0x08, 0x00}, // r
    {0x48, 0x54, 0x54, 0x54, 0x20, 0x00}, // s
    {0x04, 0x3F, 0x44, 0x40, 0x20, 0x00}, // t
    {0x3C, 0x40, 0x40, 0x20, 0x7C, 0x00}, // u
    {0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00}, // v
    {0x3C, 0x40, 0x30, 0x40, 0x3C, 0x00}, // w
    {0x44, 0x28, 0x10, 0x28, 0x44, 0x00}, // x
    {0x0C, 0x50, 0x50, 0x50, 0x3C, 0x00}, // y
    {0x44, 0x64, 0x54, 0x4C, 0x44, 0x00}, // z
    {0x00, 0x08, 0x36, 0x41, 0x00, 0x00}, // {
    {0x00, 0x00, 0x7F, 0x00, 0x00, 0x00}, // |
    {0x00, 0x41, 0x36, 0x08, 0x00, 0x00}, // }
    {0x08, 0x08, 0x2A, 0x1C, 0x08, 0x00}, // -> arrow
    {0x08, 0x1C, 0x2A, 0x08, 0x08, 0x00}, // <- arrow
};

/* ======================== I2C Low-Level Functions ======================== */

static void I2C_Start(void)
{
    LL_I2C_GenerateStartCondition(I2C1);
    while(!LL_I2C_IsActiveFlag_SB(I2C1));
}

static void I2C_Stop(void)
{
    LL_I2C_GenerateStopCondition(I2C1);
}

static void I2C_SendAddr(uint8_t addr)
{
    LL_I2C_TransmitData8(I2C1, addr);
    while(!LL_I2C_IsActiveFlag_ADDR(I2C1));
    LL_I2C_ClearFlag_ADDR(I2C1);
}

static void I2C_SendByte(uint8_t data)
{
    while(!LL_I2C_IsActiveFlag_TXE(I2C1));
    LL_I2C_TransmitData8(I2C1, data);
    while(!LL_I2C_IsActiveFlag_BTF(I2C1));
}

/* ======================== OLED Commands ======================== */

static void OLED_SendCmd(uint8_t cmd)
{
    I2C_Start();
    I2C_SendAddr(OLED_I2C_ADDR);
    I2C_SendByte(0x00);  // Command mode
    I2C_SendByte(cmd);
    I2C_Stop();
}

static void OLED_SendData(uint8_t data)
{
    I2C_Start();
    I2C_SendAddr(OLED_I2C_ADDR);
    I2C_SendByte(0x40);  // Data mode
    I2C_SendByte(data);
    I2C_Stop();
}

/* ======================== Initialization Commands ======================== */
// 参照示例驱动，0xA1+0xC8组合使用才能正确显示（上下左右同时翻转）

static const uint8_t OLED_InitCmds[] = {
    0xAE,       // Display OFF
    0xD5, 0x80, // Set display clock divide ratio/oscillator frequency
    0xA8, 0x1F, // Set multiplex ratio (1/32 duty)
    0xD3, 0x00, // Set display offset
    0x40,       // Set display start line
    0x8D, 0x14, // Enable charge pump
    0x20, 0x02, // Set memory addressing mode (Page addressing)
    0xA0,       // Set segment re-map: column 127 -> SEG0 (左右翻转)
    0xC0,       // Set COM scan direction: COM[N-1] -> COM0 (上下翻转)
    0xDA, 0x02, // Set COM pins hardware configuration (for 128x32)
    0x81, 0xEF, // Set contrast control (和示例一致)
    0xD9, 0xF1, // Set pre-charge period
    0xDB, 0x30, // Set VCOMH deselect level
    0xA4,       // Entire display ON (resume to RAM content)
    0xA6,       // Set normal display (not inverted)
    0xAF        // Display ON
};

/* ======================== Public Functions ======================== */

void OLED_Init(void)
{
    Delay_Ms(100);  // Wait for power stabilization
    
    for(uint8_t i = 0; i < sizeof(OLED_InitCmds); i++) {
        OLED_SendCmd(OLED_InitCmds[i]);
    }
    
    OLED_Clear();
    OLED_Update();
}

void OLED_Clear(void)
{
    memset(OLED_Buffer, 0x00, sizeof(OLED_Buffer));
}

void OLED_Fill(uint8_t pattern)
{
    memset(OLED_Buffer, pattern, sizeof(OLED_Buffer));
}

void OLED_Update(void)
{
    for(uint8_t page = 0; page < OLED_PAGES; page++) {
        // 和示例一致：先设置page，再设置column（先高位后低位）
        OLED_SendCmd(0xB0 + page);  // Set page address
        OLED_SendCmd(0x10);         // Set higher column address = 0
        OLED_SendCmd(0x00);         // Set lower column address = 0
        
        for(uint8_t col = 0; col < OLED_WIDTH; col++) {
            OLED_SendData(OLED_Buffer[page * OLED_WIDTH + col]);
        }
    }
}

void OLED_SetCursor(uint8_t page, uint8_t col)
{
    OLED_SendCmd(0xB0 + page);
    OLED_SendCmd(0x00 | (col & 0x0F));
    OLED_SendCmd(0x10 | (col >> 4));
}

void OLED_DrawPixel(uint8_t x, uint8_t y, uint8_t color)
{
    if(x >= OLED_WIDTH || y >= OLED_HEIGHT) return;
    
    uint16_t idx = (y / 8) * OLED_WIDTH + x;
    uint8_t bit = y % 8;
    
    if(color) {
        OLED_Buffer[idx] |= (1 << bit);
    } else {
        OLED_Buffer[idx] &= ~(1 << bit);
    }
}

void OLED_DrawChar(uint8_t x, uint8_t y, char ch, uint8_t size)
{
    if(ch < 32 || ch > 127) ch = '?';
    uint8_t idx = ch - 32;
    
    if(size == 1) {
        // 6x8 font
        for(uint8_t i = 0; i < 6; i++) {
            uint8_t line = Font6x8[idx][i];
            for(uint8_t j = 0; j < 8; j++) {
                if(line & (1 << j)) {
                    OLED_DrawPixel(x + i, y + j, 1);
                }
            }
        }
    } else {
        // 2x scaled font (12x16)
        for(uint8_t i = 0; i < 6; i++) {
            uint8_t line = Font6x8[idx][i];
            for(uint8_t j = 0; j < 8; j++) {
                if(line & (1 << j)) {
                    OLED_DrawPixel(x + i*2, y + j*2, 1);
                    OLED_DrawPixel(x + i*2 + 1, y + j*2, 1);
                    OLED_DrawPixel(x + i*2, y + j*2 + 1, 1);
                    OLED_DrawPixel(x + i*2 + 1, y + j*2 + 1, 1);
                }
            }
        }
    }
}

void OLED_DrawString(uint8_t x, uint8_t y, const char* str, uint8_t size)
{
    uint8_t charWidth = (size == 1) ? 6 : 12;
    
    while(*str) {
        if(x + charWidth > OLED_WIDTH) {
            x = 0;
            y += (size == 1) ? 8 : 16;
        }
        if(y >= OLED_HEIGHT) break;
        
        OLED_DrawChar(x, y, *str++, size);
        x += charWidth;
    }
}

void OLED_DrawStringInverse(uint8_t x, uint8_t y, const char* str, uint8_t size)
{
    uint8_t charWidth = (size == 1) ? 6 : 12;
    uint8_t charHeight = (size == 1) ? 8 : 16;
    
    // First fill background
    uint8_t len = strlen(str);
    for(uint8_t px = x; px < x + len * charWidth && px < OLED_WIDTH; px++) {
        for(uint8_t py = y; py < y + charHeight && py < OLED_HEIGHT; py++) {
            OLED_DrawPixel(px, py, 1);
        }
    }
    
    // Then draw chars with inverted pixels
    while(*str) {
        if(x + charWidth > OLED_WIDTH) break;
        
        char ch = *str++;
        if(ch < 32 || ch > 127) ch = '?';
        uint8_t idx = ch - 32;
        
        if(size == 1) {
            for(uint8_t i = 0; i < 6; i++) {
                uint8_t line = Font6x8[idx][i];
                for(uint8_t j = 0; j < 8; j++) {
                    if(line & (1 << j)) {
                        OLED_DrawPixel(x + i, y + j, 0);  // Inverted
                    }
                }
            }
        }
        x += charWidth;
    }
}

void OLED_ClearLine(uint8_t page)
{
    if(page >= OLED_PAGES) return;
    memset(&OLED_Buffer[page * OLED_WIDTH], 0, OLED_WIDTH);
}

void OLED_ClearArea(uint8_t x, uint8_t y, uint8_t w, uint8_t h)
{
    for(uint8_t px = x; px < x + w && px < OLED_WIDTH; px++) {
        for(uint8_t py = y; py < y + h && py < OLED_HEIGHT; py++) {
            OLED_DrawPixel(px, py, 0);
        }
    }
}

void OLED_ScrollUp(void)
{
    // Move pages 1-3 to 0-2
    memmove(&OLED_Buffer[0], &OLED_Buffer[OLED_WIDTH], OLED_WIDTH * (OLED_PAGES - 1));
    // Clear last page
    memset(&OLED_Buffer[OLED_WIDTH * (OLED_PAGES - 1)], 0, OLED_WIDTH);
}

void OLED_DirectDrawString(uint8_t page, uint8_t col, const char* str)
{
    OLED_SetCursor(page, col);
    
    while(*str) {
        char ch = *str++;
        if(ch < 32 || ch > 127) ch = '?';
        uint8_t idx = ch - 32;
        
        for(uint8_t i = 0; i < 6; i++) {
            OLED_SendData(Font6x8[idx][i]);
        }
    }
}